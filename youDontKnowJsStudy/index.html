<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
<script>
//如果你想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。
// function baz() {
//   // 当前调用栈是：baz
//   // 因此，当前调用位置是全局作用域
//   console.log( "baz" );
//   bar(); // <-- bar 的调用位置
// }
// function bar() {
//   // 当前调用栈是 baz -> bar
//   // 因此，当前调用位置在 baz 中
//   console.log( "bar" );
//   foo(); // <-- foo 的调用位置
// }
// function foo() {
//   // 当前调用栈是 baz -> bar -> foo
//   // 因此，当前调用位置在 bar 中
//   console.log( "foo" );
// }
// baz(); // <-- baz 的调用位置


//参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值
function foo() {
  console.log( this.a );
}
function doFoo(fn) {
  // fn 其实引用的是 foo
  fn(); // <-- 调用位置！
}
var obj = {
  a: 2,
  foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
doFoo( obj.foo ); // "oops, global"
</script>
</body>
</html>